Выводим в терминале ps -al
Видим что-то типо (это все выполняемые процессы и инфа по ним)

F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 R  1000  2223  2174  0  80   0 -  3853 -      pts/3    00:00:00 ps

Тут F - значение флагов:
0 - был fork и был exec
1 - был fork но не было exec
4 - суперюзер

Тут может быть вопрос может ли система сама выполнить exec? НЕТ, поскольку в exec в качестве параметра передаётся исполняемый файл, а система что передаст.

Тут может быть вопрос что такое супервизор? Это ОС.

Тут может быть вопрос почему exec важен или что-то подобное. Далее рассказывать дословно про оптимизацию fork:
Когда выполняется системный вызов fork создаётся ещё один процесс, называемый потомком. Для процесса потомка создаются собственные карты трансляции адресов ( таблицы страниц ), но они ссылаются на адресное пространство процесса-предка ( на страницы предка ). При этом для  страниц адресного пространства предка права доступа меняются на only- read и устанавливается флаг – copy-on-write. Если или предок или потомок попытаются изменить страницу, возникнет исключение по правам доступа. Выполняя это исключение супервизор обнаружит флаг copy-on-write и создаст копию страницы в адресном пространстве того процесса, который пытался ее изменить. Таким образом код процесса-предка не копируется полностью, а создаются только копии страниц, которые редактируются.
После перехода на новое адресное пространство предку возвращаются права доступа
read-write для сегментов данных и стека.
exec заменяет адресное пространство потомка на пространство программы, переданной
в exec и процессы перестают разделять адресное пространство.

Что делает exec? Далее тоже дословно: 
Чаще всего нет смысла в выполнении двух одинаковых процессов и потомок сразу выполняет системный вызов exec(), параметрами которого является имя исполняемого файла и, если нужно, параметры, которые будут переданы этой программе. Говорят, что системный вызов exec() создает низкоуровневый процесс: создаются таблицы страниц для адресного пространства программы, указанной в exec(), но программа на выполнение не запускается, так как это не полноценный процесс, имеющий идентификатор и дескриптор. Системный вызов exec() создает таблицу страниц для адресного пространства программы, переданной ему в качестве параметра, а затем заменяет старый адрес новой таблицы страниц.

Если попросит коротко, то exec переводит процесс на новое адрессное пространство.

q: Зачем нужна иерархия процессов в юникс?
a: Чтобы не было лавинного "сброса" информации (статусов завершения процессов).
   Чем выше процесс по иерархии, тем меньше информации поступает в него от других 
   процессов. [Можно при ответе изображать руками что-то вроде конуса - плюс в карму]

s - состояние процесса. Основные:
R - running (выполнение)
S - state(заблокирован)
Z - зомби

Далее может последовать вопрос что такое зомби: это когда процесс потомок завершил свою работу раньше процесса предка и у него (потомка) отбираюся все ресурсы, кроме строки в таблице процессов. И теперь если предок вызовет wait, то краха не будет и всё продолжит нормально работать.

UID - user id - id пользователя запустиввшего процесс
PID - id процесса
PPID parent PID - id предка процесса

C - процент использования процессом ресурса процессора(процессорного времени)

PRI - приоретет
NI - пользовательская состовляющая приоритета
WCHAN - имя системной функции (или её адресс - везде по разному написано, но в man - имя), на которой был заблокирован процесс. Что означает, что процесс заблокирован? Он не получает процессорного времени.

TTY   - терминал (не говорить телетайп!)
q: Почему у процесса в столбце tty стоит знак вопроса(?) ?
a: Этот процесс - демон. У демонов нет терминала.


остальное она меня не спрашивала, но это можно посмотреть в дропе прошлого курса, файл: ps и ls.

Далее набираем в терминале ls -al
Первый символ означает:
d - Файл является каталогом.
b - Файл является специальным блочным файлом.
c - Файл является специальным символьным файлом.
p - Файл является именованным каналом.
- - Обычный файл.
Остальные 9 символов делятся на три группы по три символа: права доступа владельца, других пользователей из его группы, всех прочих пользователей. Внутри каждой группы используются три символа, обозначающие права на чтение, запись и выполнение файла соответственно. Для каталога под правом на выполнение подразумевается право на просмотр в поисках требуемого файла.

При использовании команды  ls -l /util/by    результат выглядит примерно так:
 -rwxr-xr-x   1 root     sys           50 Jun 22 10:42 /util/by
Читая справа налево можно увидеть, что содержимое файла /util/by последний раз изменялось в 10 часов 42 минуты 22 января. Размер файла 50 байт. Владелец этого файла принадлежит группе sys, к тому же он является суперпользователем (входное имя - root). Следующее число, в данном случае 1, обозначает количество ссылок на файл /util/by. Наконец, последовательность минусов и букв указывает, что владелец, члены группы и прочие пользователи могут читать и выполнять файл, а владелец (и только он) имеет право писать в файл.

Далее идут вопросы про soft_link (ссылка на файл, а именно это специальный файл, в котором только одна строка содержащая путь по которому нужно перейти при обращении к этой ссылке, soft__link может ссылться на несуществующие файлы) и hard_link (новое имя файла и рассказывем про inode из методы:
При создании имя файла ( в Unix имя файла не является идентификатором файла в системе,  а предоставляет пользователю удобный способ обращения к файлам и их именования  -  символьный уровень файловой системы ) заносится в каталог и для адресации файла на диске создается указатель   inode ( I – Node номер ), который содержит информацию о файле. После выполнения команды ln в каталог заносится новая запись, указывающая на  inode существующего файла. Следовательно links имеют один и тот же  inode)

q: Когда файл может быть удален из системы?
a: Когда на него нет hard_link.

Далее идут 2 задания: 
1) передать сообщение по именованному каналу:
набираем в терминале:
mknod pipe p //mkfifo
echo Hello > pipe
переходин на новое окно терминала и в нём набираем 
tee < pipe
видим, что высветилось Hello
Тут pipe - это имя канала.

2) изменить приоритет процесса. Для этого запускаем прогу parent и child, где они в бесконечном цикле. Переходим на новое окно терминала. Там набираем ps -al. пишем
renice id_процесса(id дочернего процесса из ранее запущенных) 10
Туту 10 - новое значение пользовательской составляющей приоритета (NI)
Снова набираем ps -al и видим что в компоненте NI стоит теперь не 0 а 10. Изменять без root (а его у нас на тех компах нет) можно только в большую сторону. Т.е. теперь можно написать только что-то типо:
renice id_процесса 12

Q:Какие процессы 
A: Семафоры, завершение ввода/вывода, память

Q: 
A: У потомка меняется pID и указатель на предка. У предка изменяется указатель на потомка.


Вроде как всё) Удачи!
